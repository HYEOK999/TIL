![](https://cdn.pixabay.com/photo/2017/06/28/10/53/board-2450236_1280.jpg)

## 짧은 개념 정리글

#### 함수란?

여러가지 실행문들을 코드 블럭으로 묶은 하나의 실행단위.

<br/>

#### 함수 사용 이유

코드의 재사용 , 유지보수의 편의성, 코드의 신뢰성

<br/>

#### 함수객체vs일반객체

함수객체는 호출할 수 있고 일반객체는 호출할 수 없다.

<br/>

#### 함수 정의 방법

1. 함수표현문

2. 함수선언문

3. Function 생성자 함수

4. 화살표 함수

   <br/>

#### 메소드 종류

1. 인스턴스 메소드

2. 프로토타입 메소드

3. 정적 메소드

   <br/>

#### 매개변수 vs. 인수 (parameter vs. argument)

할당해주는 값이 인수고 그 값을 전달 받는게 매개변수이다.

<br/>

#### 함수정의시 동작

 모든 함수 객체는 일반 객체가 가지고 있는 메소드를 가지고, 추가적으로 [[Call]] 내부 메소드와 생성자 함수인 경우

[[Constructor]]를 가지고 있다. [[Constructor]]는 생성자 함수로서 호출이 가능한지를 알려주는 내부 메소드로, 해당 메소드를 가지고 있다면 constructor, 없다면 non-constructor이다. 이는 함수 정의 방식에 따라 결정된다.

<br/>

#### 일반 함수로서의 호출 , 생성자 함수로서의 호출

일반 함수는 호출시 함수 객체의 내부 메소드 [[Call]]가 호출 되고 

new 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다.

<br/>

#### 다양한 함수의 형태

1. 재귀함수
2. 중첩함수
3. 즉시실행함수
4. 콜백함수

<br/>

#### 스코프

JS엔진이 식별자를 찾는 규칙 , 식별자가 유효한 범위

<br/>

#### 스코프 체인

지역 스코프부터 시작하여  자신의 상위 스코프 방향으로 올라가면서 찾고자하는 식별자를 찾을 때까지 올라간다. 

<br/>

#### 순수 함수 vs 비순수

순수함수는 함수내부를 돌았을때 외부값을 변경시키지 않으며

비순수함수는 함수내부를 돌았을때 함수 외부값을 변경시키면  비순수함수이다.

<br/>

#### 전역변수의 단점

스코프의 종점에 존재하여 검색속도가 느리다.

유효범위가 넓어서 의도치않게 값을 변경시킬 수 있다

네임스페이스 오염

긴 생명주기

<br/>

#### 렉시컬 스코프

함수 호출 위치가 아닌 정의 위치에 따라 상위 스코프를 결정한다.

<br/>

#### 함수 레벨 스코프

var키워드로 선언된 변수는 함수의 코드블록만을 지역스코프로 인정한다
var 키워드가 함수 레벨 스코프. 
let , const 블록 레벨 스코프.

<br/>

#### var 키워드 문제점 3개

1. 함수 레벨 스코프
3. 변수 중복 선언 허용
4. 변수 호이스팅

<br/>

#### let 키워드 특징 3개

1. 동일 스코프 내에서 변수 중복 선언 금지
2. 블록레벨 스코프
3. 변수 호이스팅이 마치 발생 안한것처럼 동작
4. 스코프 시작지점부터 초기화 시작 지점까지의 구간을 일시적 사각지대(TDZ)라고 부른다.


<br/>

#### 생성자 함수 로직

1. 함수를 new연산자와 생성자를 호출하면 빈 객체를 생성한다.
2. this에 빈객체를 할당한다.
3. this의 빈객체 내부에서  프로퍼티 추가, 메서드 추가 등등 을 한다.
4. 생성자 함수는 마지막에 `return = this;`를 암묵적으로 실행한다. (마지막에 return을 안적어줘도 되는 이유임) (생성자 함수는 `return`을 사용하지 말아야한다.)

<br/>

#### 내부슬롯 / 내부메소드

자바스크립트엔진이 동작하기 위한 내부코드를 설명하기 위한 의사코드를 내부슬롯과 내부메소드 라고 한다. 

get 키워드가 해석되면 [[GET]] 내부메서드에 들어가서 동작을 수행한다.

set 키워드가 해석되면 [[SET]] 내부메서드에 들어가서 동작을 수행한다.

<br/>

#### 프로퍼티 정의

프로퍼티 어트리뷰트 값을 정의하여 프로퍼티의 상태를 관리하는 것.

<br/>

#### const 키워드 특징

1. 재할당 금지
2. 선언과 동시에 할당이 이루어져야한다.
3. 상수는 가독성과 유지보수의 편의가 좋다.

<br/>

#### 전역 변수 사용 억제 방법

1. 즉시실행함수
2. 네임스페이스 객체
3. 모듈패턴
4. ES6문법

<br/>

#### 전역 변수의 단점

1. 스코프 체인상 종점에 존재
2. 네임스페이스 오렴
3. 긴 생명 주기
4. 암묵적 결합

<br/>

#### 함수 객체 VS 객체

일반 객체는 호출할 수 없지만, 함수 객체는 호출할 수 있다.

<br/>

#### 데이터 프로퍼티 vs 접근자 프로퍼티

데이터프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티다.

접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을  읽거나 저장할때 사용하는 접근자함수로 구성된 프로퍼티다. 접근자 함수는 getter/setter함수라고도 부른다.

<br/>

#### 데이터 프로퍼티 어트리뷰트

[[Value]] , [[Writable]] , [[Enumerable]] , [[Configurable]]

<br/>

#### 접근자 프로퍼티 어트리뷰트

[[Get]] , [[Set]] , [[Enumerable]] , [[Configurable]]

<br/>

#### 일급 함수 객체의 특징 4가지

1. 무명의 객체를 만들 수 있다. 즉 런타임에 생성 가능하다.
2. 변수나 자료구조에 저장 할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 결과값으로 반환할 수 있다.

<br/>

#### 함수형 프로그래밍

 순수함수 와 보조함수를 이용해 부수효과를 최소한으로 하는 프로그래밍.

JS는 함수형 프로그래밍을 가능하게 한다.

<br/>

#### 인스턴스

객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어.

<br/>

#### 함수 객체에만 있는 프로퍼티
일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다.

<br/>

#### 객체를 만드는 5가지 방법

Object생성자함수(+Object.create() ) , 객체리터럴 , new생성자함수 , class

<br/>

####객체 지향 프로그래밍

객체 : 데이터와 동작을 집합으로 표현한 것.

이러한 객체를 프로그래밍으로 표현하려는 패러다임.

<br/>

#### 캡슐화

정보은닉. 외부에서 내부상태를 변경할 수 없다.

<br/>

#### 추상화

필요한 속성 만을 간추려서 표현 하는 것.

<br/>

#### 상속

어떤 객체의 프로퍼티나 메소드를 다른 객체가 물려 받아 그대로 사용하는 것.

<br/>

####프로토타입

어떤 객체의 상위 역할을 하는 객체. 다른 객체에게 공유프로퍼티를 제공한다. 모든 객체는 하나의 프로토타입을 갖는다.

프로토타입은 객체 생성 방식에 의해 결정된다.

<br/>

 #### 프로토타입 체인

객체의 프로퍼티에 접근하려고 할때 해당 객체에 접근하려는 프로퍼티가 없다면 접근자 프로퍼티가 가리키는 링크에 따라 자신의 부모 역할을 하는 프로토타입에 프로퍼티를 순차적으로 검색한다.

<br/>

#### 리터럴 방식 과 생성자 함수

| 리터럴 표기법      | 생성자 함수    | 프로토타입         |
| :----------------- | :------------- | :----------------- |
| 객체 리터럴        | [new] Object() | Object.protptype   |
| 함수 리터럴        | new Function() | Function.prototype |
| 배열 리터럴        | new Array()    | Array.prototype    |
| 정규 표현식 리터럴 | new RegExp()   | RegExp.protptype   |

 즉, 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다.

<br/>

#### 사용자 정의 생성자 함수와 프로토타입 생성 시점

함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않는다.

<br/>

#### 빌트인 생성자 함수와 프로토타입 생성 시점

모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 

<br/>

#### 객체의 프로토타입을 찾는 방법

Object.getPrototypeOf(객체명) , `객체명.__Proto__`

<br/>

#### 프로토타입이 생성자함수에 접근하는법

constructor 프로퍼티

<br/>

#### 생성자함수가 프로토타입에 접근하는 법

생성자함수명.prototype

<br/>

#### `__Proto__` 접근자 프로퍼티를 코드내에서 직접사용을 비추천하는 이유

ES5에서는 비표준이었기 때문이다. 모든 객체가 `__Proto__`를 사용할 수 없기 때문이다.

<br/>

#### 메소드의 종류3개

정적메소드 , 프로토타입메소드 , 인스턴스메소드

<br/>

#### 정적 프로퍼티/메소드

정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다.

<br/>

#### 함수호출방식에 따른 this가 가리키는 값

| 함수호출방식        | this가 가리키는 값           |
| ------------------- | ---------------------------- |
| 일반 함수로서 호출  | 전역객체                     |
| 메소드로서 호출     | 메소드를 호출한 객체         |
| 생성자함수로서 호출 | 생성자함수가 생성할 인스턴스 |

<br/>

#### this의 binding 확정시간

> 함수가 호출 되었을 때, this의 binding이 확정 된다.

**바인딩(binding)** : 바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다.

| 함수 호출 방식                                             | this 바인딩                                                  |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| 일반 함수 호출                                             | 전역 객체                                                    |
| 메소드 호출                                                | 메소드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                       |
| Function.prototype.apply/call/bind 메소드에 의한 간접 호출 | Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체 |